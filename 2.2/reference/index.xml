<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>References on MongoDB Node.js Driver</title>
    <link>/node-mongodb-native/2.2/reference/index.xml</link>
    <description>Recent content in References on MongoDB Node.js Driver</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Mar 2015 14:27:51 -0400</lastBuildDate>
    <atom:link href="/node-mongodb-native/2.2/reference/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Management</title>
      <link>/node-mongodb-native/2.2/reference/management/</link>
      <pubDate>Thu, 19 Mar 2015 14:27:51 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/management/</guid>
      <description>

&lt;h2 id=&#34;management&#34;&gt;Management&lt;/h2&gt;

&lt;p&gt;The driver provides two mechanisms for examining its state:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/node-mongodb-native/2.2/node-mongodb-native/2.2/reference/management/logging/&#34;&gt;Logging&lt;/a&gt;: Comprehensive logging of all operations.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/node-mongodb-native/2.2/node-mongodb-native/2.2/reference/management/apm/&#34;&gt;Application Performance Monitoring&lt;/a&gt;: The Application Performance Monitoring API is an API developers to tap into the commands issues to MongoDB to record performance metrics and/or inspect the commands sent to MongoDB.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CRUD Operations</title>
      <link>/node-mongodb-native/2.2/reference/ecmascript6/crud/</link>
      <pubDate>Thu, 19 Mar 2015 12:53:30 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/ecmascript6/crud/</guid>
      <description>

&lt;h1 id=&#34;ecmascript-6-crud&#34;&gt;ECMAScript 6 CRUD&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the CRUD operations from the perspective of ECMAScript 6. In this guide we will be using the same examples as in the general CRUD specification overview but rewrite them to use the new ECMAScript 6 features. For all method options refer to the main CRUD tutorial.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/node-mongodb-native/2.2/node-mongodb-native/2.2/tutorials/crud/&#34;&gt;CRUD&lt;/a&gt;: CRUD Specification.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This reference also omits methods that no longer make sense when using ECMAScript 6 such as the &lt;code&gt;each&lt;/code&gt; and &lt;code&gt;forEach&lt;/code&gt; methods.&lt;/p&gt;

&lt;h2 id=&#34;inserting-documents&#34;&gt;Inserting Documents&lt;/h2&gt;

&lt;p&gt;The &lt;em&gt;insertOne&lt;/em&gt; and &lt;em&gt;insertMany&lt;/em&gt; methods exists on the &lt;em&gt;Collection&lt;/em&gt; class and is used to insert documents into MongoDB. Code speaks a thousand words so let&amp;rsquo;s see two simple examples of inserting documents.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Insert a single document
  var r = yield db.collection(&#39;inserts&#39;).insertOne({a:1});
  assert.equal(1, r.insertedCount);

  // Insert multiple documents
  var r = yield db.collection(&#39;inserts&#39;).insertMany([{a:2}, {a:3}]);
  assert.equal(2, r.insertedCount);

  // Close connection
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at a simple example where we are writing to a replicaset and we wish to ensure that we serialize a passed in function as well as have the server assign the &lt;em&gt;_id&lt;/em&gt; for each document.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Insert a single document
  var r = yield db.collection(&#39;inserts&#39;).insertOne({
        a:1
      , b: function() { return &#39;hello&#39;; }
    }, {
        w: &#39;majority&#39;
      , wtimeout: 10000
      , serializeFunctions: true
      , forceServerObjectId: true
    });

  assert.equal(1, r.insertedCount);
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That wraps up the &lt;em&gt;insert&lt;/em&gt; methods. Next let&amp;rsquo;s look at the &lt;em&gt;update&lt;/em&gt; methods.&lt;/p&gt;

&lt;h2 id=&#34;updating-documents&#34;&gt;Updating Documents&lt;/h2&gt;

&lt;p&gt;The &lt;em&gt;updateOne&lt;/em&gt; and &lt;em&gt;updateMany&lt;/em&gt; methods exists on the &lt;em&gt;Collection&lt;/em&gt; class and is used to update and upsert documents into MongoDB. Let&amp;rsquo;s look at a couple of usage examples.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Get the updates collection
  var col = db.collection(&#39;updates&#39;);
  // Insert a single document
  var r = yield col.insertMany([{a:1}, {a:2}, {a:2}]);
  assert.equal(3, r.insertedCount);

  // Update a single document
  var r = yield col.updateOne({a:1}, {$set: {b: 1}});
  assert.equal(1, r.matchedCount);
  assert.equal(1, r.modifiedCount);

  // Update multiple documents
  var r = yield col.updateMany({a:2}, {$set: {b: 1}});
  assert.equal(2, r.matchedCount);
  assert.equal(2, r.modifiedCount);

  // Upsert a single document
  var r = yield col.updateOne({a:3}, {$set: {b: 1}}, {
    upsert: true
  });
  assert.equal(0, r.matchedCount);
  assert.equal(1, r.upsertedCount);
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;removing-documents&#34;&gt;Removing Documents&lt;/h2&gt;

&lt;p&gt;The &lt;em&gt;deleteOne&lt;/em&gt; and &lt;em&gt;deleteMany&lt;/em&gt; methods exist on the &lt;em&gt;Collection&lt;/em&gt; class and is used to remove documents from MongoDB. Let&amp;rsquo;s look at a couple of usage examples.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Get the removes collection
  var col = db.collection(&#39;removes&#39;);
  // Insert a single document
  var r = yield col.insertMany([{a:1}, {a:2}, {a:2}]);
  assert.equal(3, r.insertedCount);

  // Remove a single document
  var r = yield col.deleteOne({a:1});
  assert.equal(1, r.deletedCount);

  // Update multiple documents
  var r = yield col.deleteMany({a:2});
  assert.equal(2, r.deletedCount);
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;findoneandupdate-findoneanddelete-and-findoneandreplace&#34;&gt;findOneAndUpdate, findOneAndDelete and findOneAndReplace&lt;/h2&gt;

&lt;p&gt;The three methods &lt;em&gt;findOneAndUpdate&lt;/em&gt;, &lt;em&gt;findOneAndDelete&lt;/em&gt; and &lt;em&gt;findOneAndReplace&lt;/em&gt; are special commands that allows the user to update or upsert a document and have the modified or existing document returned. It comes at a cost as the operation takes a write lock for the duration of the operation as it needs to ensure the modification is &lt;em&gt;atomic&lt;/em&gt;. Let&amp;rsquo;s look at &lt;em&gt;findOneAndUpdate&lt;/em&gt; first using an example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Get the findAndModify collection
  var col = db.collection(&#39;findAndModify&#39;);
  // Insert a single document
  var r = yield col.insert([{a:1}, {a:2}, {a:2}]);
  assert.equal(3, r.result.n);

  // Modify and return the modified document
  var r = yield col.findOneAndUpdate({a:1}, {$set: {b: 1}}, {
      returnOriginal: false
    , sort: [[a,1]]
    , upsert: true
  });
  assert.equal(1, r.value.b);

  // Remove and return a document
  var r = yield col.findOneAndDelete({a:2});
  assert.ok(r.value.b == null);
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;findOneAndDelete&lt;/em&gt; function is a function especially defined to help remove a document. Let&amp;rsquo;s look at an example of usage.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Get the findAndModify collection
  var col = db.collection(&#39;findAndModify&#39;);
  // Insert a single document
  var r = yield col.insert([{a:1}, {a:2}, {a:2}]);
  assert.equal(3, r.result.n);

  // Remove a document from MongoDB and return it
  var r = yield col.findOneAndDelete({a:1}, {
      sort: [[a,1]]
    });
  assert.ok(r.value.b == null);
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bulkwrite&#34;&gt;BulkWrite&lt;/h2&gt;

&lt;p&gt;The &lt;em&gt;bulkWrite&lt;/em&gt; function allows for a simple set of bulk operations to be done in a non fluent way as in comparison to the bulk API discussed next. Let&amp;rsquo;s look at an example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Get the collection
  var col = db.collection(&#39;bulk_write&#39;);
  var r = yield col.bulkWrite([
      { insertOne: { document: { a: 1 } } }
    , { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
    , { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
    , { deleteOne: { filter: {c:1} } }
    , { deleteMany: { filter: {c:1} } }
    , { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true}}]
  , {ordered:true, w:1});
  assert.equal(1, r.insertedCount);
  assert.equal(1, Object.keys(r.insertedIds).length);
  assert.equal(1, r.matchedCount);
  assert.equal(0, r.modifiedCount);
  assert.equal(0, r.deletedCount);
  assert.equal(2, r.upsertedCount);
  assert.equal(2, Object.keys(r.upsertedIds).length);

  // Ordered bulk operation
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This covers the basic write operations. Let&amp;rsquo;s have a look at the Bulk write operations next.&lt;/p&gt;

&lt;h2 id=&#34;bulk-write-operations&#34;&gt;Bulk Write Operations&lt;/h2&gt;

&lt;p&gt;The bulk write operations make it easy to write groups of operations together to MongoDB. There are some caveats and to get the best performance you need to be running against MongoDB &lt;em&gt;2.6&lt;/em&gt; or higher that support the new write commands. Bulk operations are split into &lt;em&gt;ordered&lt;/em&gt; and &lt;em&gt;unordered&lt;/em&gt; bulk operations. An &lt;em&gt;ordered&lt;/em&gt; bulk operation guarantees the order of execution of writes while the &lt;em&gt;unordered&lt;/em&gt; bulk operation makes no assumptions about the order of execution. In the Node.js driver the &lt;em&gt;unordered&lt;/em&gt; bulk operations will group operations according to type and write them in parallel. Let&amp;rsquo;s have a look at how to build an ordered bulk operation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Get the collection
  var col = db.collection(&#39;bulkops&#39;);
  // Create ordered bulk, for unordered initializeUnorderedBulkOp()
  var bulk = col.initializeOrderedBulkOp();
  // Insert 10 documents
  for(var i = 0; i &amp;lt; 10; i++) {
    bulk.insert({a: i});
  }

  // Next perform some upserts
  for(var i = 0; i &amp;lt; 10; i++) {
    bulk.find({b:i}).upsert().updateOne({b:1});
  }

  // Finally perform a remove operation
  bulk.find({b:1}).deleteOne();

  // Execute the bulk with a journal write concern
  var result = yield bulk.execute();
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will not cover the results object here as it&amp;rsquo;s documented in the driver API. The Bulk API handles all the splitting of operations into multiple writes and also emulates 2.6 and higher write commands for 2.4 and earlier servers.&lt;/p&gt;

&lt;p&gt;There are some important things to keep in mind when using the bulk API and especially the &lt;em&gt;ordered&lt;/em&gt; bulk API mode. The write commands are single operation type. That means they can only do insert/update and remove. If you f.ex do the following combination of operations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Insert {a:1}
Update {a:1} to {a:1, b:1}
Insert {a:2}
Remove {b:1}
Insert {a:3}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will result in the driver issuing 4 write commands to the server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Insert Command with {a:1}
Update Command {a:1} to {a:1, b:1}
Insert Command with {a:2}
Remove Command with {b:1}
Insert Command with {a:3}    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you instead organize your &lt;em&gt;ordered&lt;/em&gt; in the following manner.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Insert {a:1}
Insert {a:2}
Insert {a:3}
Update {a:1} to {a:1, b:1}
Remove {b:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number of write commands issued by the driver will be.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Insert Command with {a:1}, {a:2}, {a:3}
Update Command {a:1} to {a:1, b:1}
Remove Command with {b:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Allowing for more efficient and faster bulk write operation.&lt;/p&gt;

&lt;p&gt;For &lt;em&gt;unordered&lt;/em&gt; bulk operations this is not important as the driver sorts operations by type and executes them in parallel.&lt;/p&gt;

&lt;p&gt;This covers write operations for MongoDB. Let&amp;rsquo;s look at querying for documents next.&lt;/p&gt;

&lt;h2 id=&#34;read-methods&#34;&gt;Read Methods&lt;/h2&gt;

&lt;p&gt;The main method for querying the database are the &lt;em&gt;find&lt;/em&gt; and the &lt;em&gt;aggregate&lt;/em&gt; method. In this CRUD tutorial we will focus on &lt;em&gt;find&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;method&lt;/em&gt; return a cursor that allows us to operate on the data. The &lt;em&gt;cursor&lt;/em&gt; also implements the Node.js 0.10.x or higher stream interface allowing us to pipe the results to other streams.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at a simple find example that materializes all the documents from a query using the toArray but limits the number of returned results to 2 documents.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Get the collection
  var col = db.collection(&#39;find&#39;);
  // Insert a single document
  var r = yield col.insertMany([{a:1}, {a:1}, {a:1}]);
  assert.equal(3, r.insertedCount);

  // Get first two documents that match the query
  var docs = yield col.find({a:1}).limit(2).toArray();
  assert.equal(2, docs.length);
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next lets take a look at the &lt;em&gt;next&lt;/em&gt; method and how we can iterate over the cursor in ECMAScript 6. The new &lt;code&gt;generator&lt;/code&gt; functions allow for what is arguably a much cleaner and easier to read iteration code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Get the collection
  var col = db.collection(&#39;find&#39;);
  // Insert a single document
  var r = yield col.insertMany([{a:1}, {a:1}, {a:1}]);
  assert.equal(3, r.insertedCount);

  // Get the cursor
  var cursor = col.find({a:1}).limit(2);

  // Iterate over the cursor
  while(yield cursor.hasNext()) {
    var doc = yield cursor.next();
    console.dir(doc);
  }

  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;executing-commands&#34;&gt;Executing Commands&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Db.command&lt;/code&gt; method also returns a &lt;code&gt;Promise&lt;/code&gt; allowing us to leverage &lt;code&gt;generators&lt;/code&gt; to get clear and concise code. Below is an example calling the &lt;code&gt;buildInfo&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var db = yield MongoClient.connect(&#39;mongodb://localhost:27017/myproject&#39;);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);
  // Use the admin database for the operation
  var adminDb = db.admin();
  // Retrive the build information using the admin command
  yield adminDb.command({buildInfo:1})
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Connecting</title>
      <link>/node-mongodb-native/2.2/reference/ecmascript6/connecting/</link>
      <pubDate>Thu, 19 Mar 2015 12:53:30 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/ecmascript6/connecting/</guid>
      <description>

&lt;h1 id=&#34;connecting&#34;&gt;Connecting&lt;/h1&gt;

&lt;p&gt;The MongoClient connection method returns a Promise if no callback is passed to it. Below is an example using the &lt;a href=&#34;https://www.npmjs.com/package/co&#34;&gt;co&lt;/a&gt; package to run a &lt;code&gt;generator&lt;/code&gt; function, which is one of the most exciting innovations of ECMAScript 6.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  co = require(&#39;co&#39;),
  assert = require(&#39;assert&#39;);

co(function*() {
  // Connection URL
  var url = &#39;mongodb://localhost:27017/myproject&#39;;
  // Use connect method to connect to the Server
  var db = yield MongoClient.connect(url);
  // Close the connection
  db.close();
}).catch(function(err) {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;MongoClient.connect&lt;/code&gt; function returns a &lt;code&gt;Promise&lt;/code&gt; that we then execute using the &lt;code&gt;yield&lt;/code&gt; keyword of the &lt;code&gt;generator&lt;/code&gt; function. If an error happens during the &lt;code&gt;MongoClient.connect&lt;/code&gt; the error is caught by &lt;code&gt;co&lt;/code&gt; and can be inspected by attaching a function to the &lt;code&gt;catch&lt;/code&gt; method as shown above.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Connection Options</title>
      <link>/node-mongodb-native/2.2/reference/connecting/</link>
      <pubDate>Thu, 19 Mar 2015 12:53:30 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/connecting/</guid>
      <description>

&lt;h1 id=&#34;connection-options&#34;&gt;Connection Options&lt;/h1&gt;

&lt;p&gt;For more information on the connection options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.mongodb.org/manual/reference/connection-string/&#34;&gt;URI Connection String&lt;/a&gt;: MongoDB connection string URI.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/node-mongodb-native/2.2/node-mongodb-native/2.2/reference/connecting/connection-settings/&#34;&gt;Connection Settings&lt;/a&gt;: Reference on the driver-specific connection settings.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Connection Settings</title>
      <link>/node-mongodb-native/2.2/reference/connecting/connection-settings/</link>
      <pubDate>Thu, 19 Mar 2015 12:53:30 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/connecting/connection-settings/</guid>
      <description>

&lt;h1 id=&#34;uri-connection-settings&#34;&gt;URI Connection Settings&lt;/h1&gt;

&lt;p&gt;Optional connection settings are settings not covered by the &lt;a href=&#34;https://docs.mongodb.org/manual/reference/connection-string/&#34;&gt;URI Connection String &lt;/a&gt;. The following options are passed in the options parameter in the MongoClient.connect function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient
  , assert = require(&#39;assert&#39;);

// Connection URL
var url = &#39;mongodb://localhost:50000,localhost:50001/myproject&#39;;
// Use connect method to connect to the Server passing in
// additional options
MongoClient.connect(url, {
  poolSize: 10, ssl: true
}, function(err, db) {
  assert.equal(null, err);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  db.close();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The table below shows all settings and what topology they affect.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Option&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Affects&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Default&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;poolSize&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Set the maximum poolSize for each individual server or proxy connection.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;ssl&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Use ssl connection (needs to have a mongod server with ssl support)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;sslValidate&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;sslCA&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Array&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;sslCert&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Buffer/String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;sslKey&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Buffer/String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;sslPass&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Buffer/String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;autoReconnect&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Reconnect on error.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;noDelay&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Socket NoDelay option.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;keepAlive&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The number of milliseconds to wait before initiating keepAlive on the TCP socket.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;connectTimeoutMS&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;30000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Connection timeout setting.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;socketTimeoutMS&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;30000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Socket timeout setting.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;reconnectTries&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;30&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server attempt to reconnect #times&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;reconnectInterval&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server will wait # milliseconds between retries.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;ha&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Turn on high availability monitoring.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;haInterval&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;10000,5000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Time between each replicaset status check.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;replicaSet&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ReplicaSet&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;string&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The name of the replicaset to connect to.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;secondaryAcceptableLatencyMS&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ReplicaSet&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;acceptableLatencyMS&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;connectWithNoPrimary&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ReplicaSet&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sets if the driver should connect even if no primary is available.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;authSource&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;string&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;If the database authentication is dependent on another databaseName.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;w&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;string, integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The write concern.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;wtimeout&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The write concern timeout value.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;j&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Specify a journal write concern.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;forceServerObjectId&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Force server to assign _id values instead of driver.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;serializeFunctions&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Serialize functions on any object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;ignoreUndefined&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Specify if the BSON serializer should ignore undefined fields.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;raw&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Return document results as raw BSON buffers.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;promoteLongs&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Promotes Long values to number if they fit inside the 53 bits resolution.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;promoteBuffers&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Promotes Binary BSON values to native Node Buffers.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;promoteValues&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Promotes BSON values to native types where possible, set to false to only receive wrapper types.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;domainsEnabled&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;bufferMaxEntries&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;integer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;readPreference&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;object&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;pkFactory&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;object&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;A primary key factory object for generation of custom _id keys.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;promiseLibrary&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;object&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;readConcern&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, ReplicaSet, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;object&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Specify a read concern for the collection. (only MongoDB 3.2 or higher supported).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;maxStalenessSeconds&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Replicaset&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;number&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Specify a maxStalenessSeconds value for secondary reads, minimum is 90 seconds&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;loggerLevel&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;string&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Specify the log level used by the driver logger (error/warn/info/debug)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;logger&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;object&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Specify a customer logger mechanism, can be used to log using your app level logger&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;ensure-you-connection-string-is-valid-for-replica-sets&#34;&gt;Ensure you connection string is valid for Replica Sets&lt;/h1&gt;

&lt;p&gt;The connection string passed to the driver must use the fully qualified host names for the servers as set in the replicaset config. Given the following configuration settings for your replicaset.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
	&amp;quot;_id&amp;quot; : &amp;quot;testSet&amp;quot;,
	&amp;quot;version&amp;quot; : 1,
	&amp;quot;protocolVersion&amp;quot; : 1,
	&amp;quot;members&amp;quot; : [
		{
			&amp;quot;_id&amp;quot; : 1,
			&amp;quot;host&amp;quot; : &amp;quot;server1:31000&amp;quot;,
		},
		{
			&amp;quot;_id&amp;quot; : 2,
			&amp;quot;host&amp;quot; : &amp;quot;server2:31001&amp;quot;,
		},
		{
			&amp;quot;_id&amp;quot; : 3,
			&amp;quot;host&amp;quot; : &amp;quot;server3:31002&amp;quot;,
		}
	]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You must ensure &lt;code&gt;server1&lt;/code&gt;, &lt;code&gt;server2&lt;/code&gt; and &lt;code&gt;server3&lt;/code&gt; are resolvable from the driver for the Replicaset discovery and failover to work correctly.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ECMAScript 6</title>
      <link>/node-mongodb-native/2.2/reference/ecmascript6/</link>
      <pubDate>Thu, 19 Mar 2015 12:53:30 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/ecmascript6/</guid>
      <description>

&lt;h1 id=&#34;ecmascript-6&#34;&gt;ECMAScript 6&lt;/h1&gt;

&lt;p&gt;ECMAScript 6 or JavaScript 6 as it&amp;rsquo;s more commonly known is the new future of the Javascript language. It introduces fundamental changes in JavaScript while maintaining backward compatibility with ECMAScript 5.&lt;/p&gt;

&lt;p&gt;The MongoDB Node.js driver embraces the new JavaScript version to provide the end user with much improved functionality. We do this primarily by exposing Promises for all &lt;code&gt;async&lt;/code&gt; methods without breaking backward compatibility with existing code using the driver.&lt;/p&gt;

&lt;p&gt;This section exposes how to use the MongoDB Node.js driver with ECMAScript 6, leveraging all the productivity gains you get from the new Generators.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
&lt;p&gt;For more information about ECMAScript 6 see the &lt;a href=&#34;http://es6-features.org/&#34;&gt;ECMAScript 6 features&lt;/a&gt;.&lt;/p&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/node-mongodb-native/2.2/node-mongodb-native/2.2/reference/ecmascript6/connecting/&#34;&gt;Connecting&lt;/a&gt;: how to connect leveraging ECMAScript 6.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/node-mongodb-native/2.2/node-mongodb-native/2.2/reference/ecmascript6/crud/&#34;&gt;CRUD&lt;/a&gt;: perform CRUD operations leveraging ECMAScript 6.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Frequently Asked Questions</title>
      <link>/node-mongodb-native/2.2/reference/faq/</link>
      <pubDate>Thu, 19 Mar 2015 12:53:30 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/faq/</guid>
      <description>

&lt;h1 id=&#34;what-is-the-difference-between-connecttimeoutms-sockettimeoutms-and-maxtimems&#34;&gt;What is the difference between connectTimeoutMS, socketTimeoutMS and maxTimeMS ?&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Setting&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Default Value MongoClient.connect&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;connectTimeoutMS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;30000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The connectTimeoutMS sets the number of milliseconds a socket stays inactive before closing during the connection phase of the driver. That is to say, when the application initiates a connection, when a replica set connects to new members, or when a replica set reconnects to members. A value of 10000 milliseconds would mean the driver would wait up to 10 seconds for a response from a MongoDB server.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;socketTimeoutMS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;30000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The socketTimeoutMS sets the number of milliseconds a socket stays inactive after the driver has successfully connected before closing. If the value is set to 30000 milliseconds, the socket closes if there is no activity during a 30 seconds window.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;maxTimeMS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N/A&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The maxTimeMS setting specifies how long MongoDB should run an operation before cancelling it. If the maxTimeMS is set to 10000 milliseconds, any operation that runs over that limit returns a timeout error.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;fail-fast-during-connection&#34;&gt;Fail fast during connection&lt;/h4&gt;

&lt;p&gt;In this scenario, the developer wants to ensure that the driver does not
hang during the connection phase or spend an unnecessarily long time
attempting to connect to replica set members who are not reachable.&lt;/p&gt;

&lt;p&gt;As a general rule you should ensure that the &lt;code&gt;connectTimeoutMS&lt;/code&gt; setting
is not lower than the longest network latency you have to a member of
the set. If one of the &lt;code&gt;secondary&lt;/code&gt; members is on the other side of the
planet and has a latency of 10000 milliseconds, setting the
&lt;code&gt;connectTimeoutMS&lt;/code&gt; to anything lower will prevent the driver from ever
connecting to that member.&lt;/p&gt;

&lt;h3 id=&#34;sockettimeoutms-as-a-way-to-abort-operations&#34;&gt;socketTimeoutMS as a way to abort operations&lt;/h3&gt;

&lt;p&gt;Developers sometimes try to use &lt;code&gt;socketTimeoutMS&lt;/code&gt;
to end operations which may run for too long and slow
down the application, but doing so may not achieve the intended result.&lt;/p&gt;

&lt;p&gt;Closing the socket forces a reconnect of the driver&amp;rsquo;s connection pool
and introduces latency to any other operations which are queued up.
Chronically slow operations will therefore cause a large number of
reconnect requests, negatively impacting throughput and performance.&lt;/p&gt;

&lt;p&gt;Also, closing the socket does not terminate the operation; it will continue
to run on the MongoDB server, which could cause data inconsistencies
if the application retries the operation on failure.&lt;/p&gt;

&lt;p&gt;That said, there are some important use cases for &lt;code&gt;socketTimeoutMS&lt;/code&gt;. It&amp;rsquo;s
possible that a MongoDB process may error out, or that a misconfigured
firewall may close a socket connection without sending a &lt;code&gt;FIN&lt;/code&gt; packet.
In these cases there is no way for the driver to detect that the
connection has died, and &lt;code&gt;socketTimeoutMS&lt;/code&gt; is essential to ensure that the
sockets are closed correctly.&lt;/p&gt;

&lt;p&gt;A good rule of thumb is to set &lt;code&gt;socketTimeoutMS&lt;/code&gt; to two to three times the
length of the slowest operation which runs through the driver.&lt;/p&gt;

&lt;h3 id=&#34;sockettimeoutms-and-large-connection-pools&#34;&gt;socketTimeoutMS and large connection pools&lt;/h3&gt;

&lt;p&gt;Having a large connection pool does not always reduce reconnection
requests. Consider the following example: an application has
a connection pool size of 5 sockets and has &lt;code&gt;socketTimeoutMS&lt;/code&gt; set
to 5000 milliseconds. Operations occur, on average, every 3000
milliseconds, and reconnection requests are frequent.
Each socket times out after 5000 milliseconds, which means that all
sockets must do something during that 5000 millisecond period to
avoid closing. One message every 3000 milliseconds is not enough to
keep the sockets active, so several of the sockets will time out
after 5000 milliseconds.&lt;/p&gt;

&lt;p&gt;Reducing the pool size to 1 will fix the problem.&lt;/p&gt;

&lt;h3 id=&#34;the-special-meaning-of-0&#34;&gt;The special meaning of 0&lt;/h3&gt;

&lt;p&gt;Setting &lt;code&gt;connectTimeoutMS&lt;/code&gt; and &lt;code&gt;socketTimeoutMS&lt;/code&gt; to the value 0 has
a special meaning. It causes the application to use the operating
system&amp;rsquo;s default socket timeout value.&lt;/p&gt;

&lt;h3 id=&#34;maxtimems-is-the-option-you-are-looking-for&#34;&gt;maxTimeMS is the option you are looking for&lt;/h3&gt;

&lt;p&gt;Many developers set a low &lt;code&gt;socketTimeoutMS&lt;/code&gt; value, intending
to prevent long-running server operations from slowing down
the application. &lt;code&gt;maxTimeMS&lt;/code&gt; is usually a better choice; it allows
MongoDB itself to cancel operations which run for more than &lt;code&gt;maxTimeMS&lt;/code&gt;
milliseconds.&lt;/p&gt;

&lt;p&gt;The following example demonstrates how to use &lt;code&gt;MaxTimeMS&lt;/code&gt; with a &lt;code&gt;find&lt;/code&gt;
operation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Execute a find command
col.find({&amp;quot;$where&amp;quot;: &amp;quot;sleep(100) || true&amp;quot;})
  .maxTimeMS(50)
  .count(function(err, count) {
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;what-does-the-keepalive-setting-do&#34;&gt;What does the keepAlive setting do?&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;keepAlive&lt;/code&gt; is a socket setting available from Node.js that in theory
will keep a socket alive by sending periodic probes to MongoDB.
However, this only works if the operating system supports
&lt;code&gt;SO_KEEPALIVE&lt;/code&gt;, and still might not work if a firewalls
ignores or drops the &lt;code&gt;keepAlive&lt;/code&gt; packets.&lt;/p&gt;

&lt;h3 id=&#34;on-misconfigured-firewalls&#34;&gt;On misconfigured firewalls&lt;/h3&gt;

&lt;p&gt;Internal firewalls which exist between application servers and MongoDB
are often misconfigured, and are overly aggressive in their culling of
socket connections. If you experience unexpected network behavior, here
are some things to check:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The firewall should send a FIN packet when closing a socket,
allowing the driver to detect that the socket is closed.&lt;/li&gt;
&lt;li&gt;The firewall should allow keepAlive probes.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;i-m-getting-econnreset-when-calling-mongoclient-connect&#34;&gt;I&amp;rsquo;m getting ECONNRESET when calling MongoClient.connect&lt;/h1&gt;

&lt;p&gt;This can occur if the connection pool is too large.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;MongoClient.connect(&#39;mongodb://localhost:27017/test?maxPoolSize=5000&#39;,
  function(err, db) {
    // connection
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this operation causes an &lt;code&gt;ECONNRESET&lt;/code&gt; error, you may have run into
the file descriptor limit for your Node.js process.&lt;/p&gt;

&lt;p&gt;In most operating systems, each socket connection is associated with a
file descriptor. Many operating systems have a limit on how many such
file descriptors can be used by a single process.&lt;/p&gt;

&lt;p&gt;The way to fix the descriptor limit issue is to increase the number of
file descriptors for the Node.js process. On Mac OS and Linux you do
this with the &lt;code&gt;ulimit&lt;/code&gt; shell command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ulimit -n 6000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This sets the maximum number of file descriptors for the process to
6000, allowing Node.js to connect with a pool size of 5000 sockets.&lt;/p&gt;

&lt;h1 id=&#34;how-can-i-prevent-a-slow-operation-from-delaying-other-operations&#34;&gt;How can I prevent a slow operation from delaying other operations?&lt;/h1&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
&lt;p&gt;The driver is only affected by the slow train operations if the number of slow operations is larger than the max pool size.&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;While Node.js is asynchronous, MongoDB is not. Currently, MongoDB uses a single execution thread per socket. This means that it will only execute a single operation on a socket at any given point in time. Any other operations sent to that socket will have to wait until the current operation is finished. If you have a slow-running operation which holds up other operations,
the best solution is to create a separate connection pool for the slow operation, isolating it from other, faster
operations.&lt;/p&gt;

&lt;h1 id=&#34;ensure-your-connection-string-is-valid-for-replica-set&#34;&gt;Ensure your connection string is valid for Replica Set&lt;/h1&gt;

&lt;p&gt;The connection string passed to the driver &lt;strong&gt;MUST&lt;/strong&gt; use the fully qualified host names for the servers as set in the replicaset config. Given the following configuration settings for your replicaset.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
	&amp;quot;_id&amp;quot; : &amp;quot;testSet&amp;quot;,
	&amp;quot;version&amp;quot; : 1,
	&amp;quot;protocolVersion&amp;quot; : 1,
	&amp;quot;members&amp;quot; : [
		{
			&amp;quot;_id&amp;quot; : 1,
			&amp;quot;host&amp;quot; : &amp;quot;server1:31000&amp;quot;,
		},
		{
			&amp;quot;_id&amp;quot; : 2,
			&amp;quot;host&amp;quot; : &amp;quot;server2:31001&amp;quot;,
		},
		{
			&amp;quot;_id&amp;quot; : 3,
			&amp;quot;host&amp;quot; : &amp;quot;server3:31002&amp;quot;,
		}
	]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You must ensure &lt;code&gt;server1&lt;/code&gt;, &lt;code&gt;server2&lt;/code&gt; and &lt;code&gt;server3&lt;/code&gt; are resolvable from the driver for the Replicaset discovery and failover to work correctly.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Legacy Connection Settings</title>
      <link>/node-mongodb-native/2.2/reference/connecting/legacy-connection-settings/</link>
      <pubDate>Thu, 19 Mar 2015 12:53:30 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/connecting/legacy-connection-settings/</guid>
      <description>

&lt;h1 id=&#34;connect-to-mongodb-legacy&#34;&gt;Connect To MongoDB (Legacy)&lt;/h1&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
&lt;p&gt;For 2.1.10 or earlier. For newer versions, see &lt;a href=&#34;/node-mongodb-native/2.2/node-mongodb-native/2.2/reference/connecting/&#34;&gt;Connect to MongoDB&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;Connecting to MongoDB using the driver is primarily done using the &lt;code&gt;MongoClient.connect&lt;/code&gt; method and a URI. Let&amp;rsquo;s look at how we connect to a couple of different server topologies.&lt;/p&gt;

&lt;h2 id=&#34;single-server-connection&#34;&gt;Single Server Connection&lt;/h2&gt;

&lt;p&gt;We have a single MongoDB server instance running on the port &lt;em&gt;27017&lt;/em&gt; Let&amp;rsquo;s connect using the driver and &lt;em&gt;MongoClient.connect&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient
  , assert = require(&#39;assert&#39;);

// Connection URL
var url = &#39;mongodb://localhost:27017/myproject&#39;;
// Use connect method to connect to the Server
MongoClient.connect(url, function(err, db) {
  assert.equal(null, err);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  db.close();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s break down the &lt;code&gt;URI&lt;/code&gt; string we passed as the first argument to MongoClient.connect.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;mongodb://&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the protocol definition&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;localhost:27017&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the server we are connecting to&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;/myproject&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the database we wish to connect to&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;replicaset-server-connection&#34;&gt;Replicaset Server Connection&lt;/h2&gt;

&lt;p&gt;We wish to connect to a ReplicaSet consisting of one primary and 1 or more secondaries. To Do this we need to supply the driver with a seedlist of servers and the name of the ReplicaSet we wish to connect to. Let&amp;rsquo;s take a look at a code example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient
  , assert = require(&#39;assert&#39;);

// Connection URL
var url = &#39;mongodb://localhost:27017,localhost:27018/myproject?replicaSet=foo&#39;;
// Use connect method to connect to the Server
MongoClient.connect(url, function(err, db) {
  assert.equal(null, err);
  console.log(&#34;Connected correctly to server&#34;);

  db.close();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s break down the &lt;code&gt;URI&lt;/code&gt; string.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;mongodb://&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the protocol definition&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;localhost:27017,localhost:27018&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the servers we are connecting to to discover the topology of the ReplicaSet.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;/myproject&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the database we wish to connect to&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;replicaSet=foo&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the name of the ReplicaSet we are connecting to. This ensures we are connecting to the correct Replicaset. &lt;strong&gt;This is a required parameter when using the 2.0 driver&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;mongos-proxy-connection&#34;&gt;Mongos Proxy Connection&lt;/h2&gt;

&lt;p&gt;We wish to connect to a set of &lt;code&gt;mongos&lt;/code&gt; proxies. Just as in the case of connecting to a ReplicaSet we can provide a seed list of &lt;code&gt;mongos&lt;/code&gt; proxies. This allows the driver to perform failover between proxies automatically in case of a proxy process having been shut down. Let&amp;rsquo;s look at an example of code connecting to a set of proxies.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient
  , assert = require(&#39;assert&#39;);

// Connection URL
var url = &#39;mongodb://localhost:50000,localhost:50001/myproject&#39;;
// Use connect method to connect to the Server
MongoClient.connect(url, function(err, db) {
  assert.equal(null, err);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  db.close();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s break down the &lt;code&gt;URI&lt;/code&gt; string.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;mongodb://&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the protocol definition&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;localhost:50000,localhost:50001&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the &lt;em&gt;mongos&lt;/em&gt; proxies we are connecting to.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;/myproject&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the database we wish to connect to&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Let&amp;rsquo;s break down the &lt;code&gt;URI&lt;/code&gt; string.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;mongodb://&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the protocol definition&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;dave:password&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the user name and password for the database&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;localhost:27017&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the server we are connecting to&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;/myproject&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the database we wish to connect to&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;authSource=admin&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;is the database we wish to authenticate against&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;mongoclient-connect-optional-parameters&#34;&gt;MongoClient.connect Optional Parameters&lt;/h1&gt;

&lt;p&gt;The driver has many more options for tweaking than what&amp;rsquo;s available through the &lt;code&gt;URI&lt;/code&gt; specification. These can be passed to the driver using an optional parameters object. The top level fields in the options object are.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;db&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Options that affect the Db instance returned by the MongoClient.connect method.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;replSet&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Options that modify the Replicaset topology connection behavior. &lt;strong&gt;This is a required parameter when using the 2.0 driver&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;mongos&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Options that modify the Mongos topology connection behavior.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;server&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Options that modify the Server topology connection behavior.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;A simple example connecting to a single server setting all returned queries to be raw BSON buffers and adjusting the poolSize to be 10 connections for this connection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient
  , assert = require(&#39;assert&#39;);

// Connection URL
var url = &#39;mongodb://dave:password@localhost:27017/myproject&#39;;
// Use connect method to connect to the Server
MongoClient.connect(url, {
    db: {
      raw: true
    },
    server: {
      poolSize: 10
    }
  }, function(err, db) {
  assert.equal(null, err);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  db.close();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at the individual options for each of the top level fields.&lt;/p&gt;

&lt;h2 id=&#34;data-base-level-options&#34;&gt;Data base level options&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number/String, &amp;gt; -1 || &amp;lsquo;majority&amp;rsquo;}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the write concern for the operation where &amp;lt; 1 is no acknowledgment of write and w &amp;gt;= 1 or w = &amp;lsquo;majority&amp;rsquo; acknowledges the write&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;wtimeout&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, 0}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;set the timeout for waiting for write concern to finish (combines with w option)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;fsync&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;(Boolean, default:false)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;write waits for fsync before returning&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;j&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;(Boolean, default:false)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;write waits for journal sync before returning&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;readPreference&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{String}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;readPreferenceTags&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Object, default:null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the tags object {&amp;lsquo;loc&amp;rsquo;:&amp;lsquo;ny&amp;rsquo;} used with the readPreference.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;native_parser&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default:false}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;use c++ bson parser.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;forceServerObjectId&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default:false}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;force server to create _id fields instead of client.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;pkFactory&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Object}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;object overriding the basic ObjectID primary key generation.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;serializeFunctions&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default:false}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;serialize functions.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;raw&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default:false}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;perform operations using raw bson buffers.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;bufferMaxEntries&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: -1}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If you are connecting to a MongoDB replicaset, you pass the parameters using the &lt;code&gt;replset&lt;/code&gt; options field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  f = require(&#39;util&#39;).format,
  fs = require(&#39;fs&#39;);

MongoClient.connect(f(&#39;mongodb://%s@server:27017/test&#39;), {
  db: {
    w:1
  }
}, function(err, db) {
  db.close();
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;individual-server-level-options&#34;&gt;Individual Server Level Options&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;poolSize&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 5}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default: false}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Use ssl connection (needs to have a mongod server with ssl support).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslValidate&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default: true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;checkServerIdentity&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean|Function, default: true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslCA&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer[]|string[], default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslCert&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer|string, default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslKey&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer|string, default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslPass&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer|string, default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;autoReconnect&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default: true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Reconnect on error.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.noDelay&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default: true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Socket NoDelay option.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.keepAlive&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 0}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The number of milliseconds to wait before initiating keepAlive on the TCP socket.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.connectTimeoutMS&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 30000}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Connection timeout setting.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.socketTimeoutMS&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 30000}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Socket timeout setting.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If you are connecting to a single MongoDB instance you pass the parameters using the &lt;code&gt;server&lt;/code&gt; options field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  f = require(&#39;util&#39;).format,
  fs = require(&#39;fs&#39;);

MongoClient.connect(f(&#39;mongodb://%s@server:27017/test&#39;), {
  server: {
      sslKey:key
    , sslCert:cert
  }
}, function(err, db) {
  db.close();
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;replicaset-level-options&#34;&gt;Replicaset Level Options&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;ha&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default:true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Controls if the replicaset monitoring runs or not.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;haInterval&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default:10000}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The number of milliseconds between each ping of the replicaset members. The replicaset monitoring process, is the process monitoring the replicaset, detecting new members and reconnecting to existing members.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;replicaSet&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{String}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the name of the replicaset to connect to. &lt;strong&gt;This is a required parameter when using the 2.0 driver&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;secondaryAcceptableLatencyMS&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default:15}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;connectWithNoPrimary&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default:false}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sets if the driver should connect even if no primary is available.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;poolSize&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 5}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default: false}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Use ssl connection (needs to have a mongod server with ssl support).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslValidate&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default: true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;checkServerIdentity&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean|Function, default: true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslCA&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer[]|string[], default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslCert&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer|string, default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslKey&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer|string, default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslPass&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer|string, default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.noDelay&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default: true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Socket NoDelay option.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.keepAlive&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 0}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The number of milliseconds to wait before initiating keepAlive on the TCP socket.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.connectTimeoutMS&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 0}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Connection timeout setting.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.socketTimeoutMS&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 0}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Socket timeout setting.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If you are connecting to a MongoDB replicaset, you pass the parameters using the &lt;code&gt;replset&lt;/code&gt; options field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  f = require(&#39;util&#39;).format,
  fs = require(&#39;fs&#39;);

MongoClient.connect(f(&#39;mongodb://%s@server:27017/test&#39;), {
  replset: {
      sslKey:key
    , sslCert:cert
  }
}, function(err, db) {
  db.close();
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mongos-proxy-level-options&#34;&gt;Mongos Proxy Level Options&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;ha&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default:true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;turn on high availability.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;haInterval&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default:5000}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;time between each replicaset status check.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;secondaryAcceptableLatencyMS&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default:15}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;poolSize&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 5}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default: false}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Use ssl connection (needs to have a mongod server with ssl support).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslValidate&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default: true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;checkServerIdentity&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean|Function, default: true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslCA&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer[]|string[], default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslCert&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer|string, default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslKey&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer|string, default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;sslPass&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Buffer|string, default: null}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.noDelay&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Boolean, default: true}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Socket NoDelay option.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.keepAlive&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 0}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The number of milliseconds to wait before initiating keepAlive on the TCP socket.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.connectTimeoutMS&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 0}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Connection timeout setting.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;socketOptions.socketTimeoutMS&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{Number, default: 0}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TCP Socket timeout setting.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If you are connecting to a MongoDB replicaset, you pass the parameters using the &lt;code&gt;mongos&lt;/code&gt; options field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient,
  f = require(&#39;util&#39;).format,
  fs = require(&#39;fs&#39;);

MongoClient.connect(f(&#39;mongodb://%s@server:27017/test&#39;), {
  mongos: {
      sslKey:key
    , sslCert:cert
  }
}, function(err, db) {
  db.close();
});

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Pool Design</title>
      <link>/node-mongodb-native/2.2/reference/pool/</link>
      <pubDate>Thu, 19 Mar 2015 12:53:30 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/pool/</guid>
      <description>

&lt;h1 id=&#34;driver-pool-design&#34;&gt;Driver Pool Design&lt;/h1&gt;

&lt;p&gt;The 2.0 series of the mongodb-core module introduces a newly re-designed pool that will grow and contract based on the usage pattern. This reference outlines how the growing/shrinking of the pool works, how authentication is handled and how operations are executed.&lt;/p&gt;

&lt;p&gt;Operations are executed using a work-queue. That means the Pool is responsible for scheduling the execution of operations on connections. The benefit of this is that one avoids slow operations holding up fast operations as long as the following holds true.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;numberOfSlowOps &amp;lt; numberOfConnectionsInPool
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pool-growth-shrinking&#34;&gt;Pool Growth/Shrinking&lt;/h2&gt;

&lt;p&gt;This covers the basics of how the pool grows and shrinks.&lt;/p&gt;

&lt;h3 id=&#34;initial-pool-connection&#34;&gt;Initial Pool connection&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Single connection is created and put in the &lt;code&gt;connectingConnections&lt;/code&gt; array.&lt;/li&gt;
&lt;li&gt;On Successful connect, reapply any existing authentication credentials on the connection.&lt;/li&gt;
&lt;li&gt;If the user passed in credentials through the &lt;code&gt;Pool.connect&lt;/code&gt; method these are then applied to the connection and stored in the credentials store if successful.&lt;/li&gt;
&lt;li&gt;Finally the connection is moved from the &lt;code&gt;connectingConnections&lt;/code&gt;
to &lt;code&gt;availableConnections&lt;/code&gt; and the &lt;code&gt;connect&lt;/code&gt; event is emitted.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If the initial connection fails the server returns the associated failure event (close, error, timeout, parseError). The &lt;code&gt;Pool.connect&lt;/code&gt; method will also fail if the authentication fails for any existing or given credentials.&lt;/p&gt;

&lt;h3 id=&#34;growing-the-pool&#34;&gt;Growing the Pool&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;A new operation is scheduled to be executed.&lt;/li&gt;
&lt;li&gt;Pool checks if there are any connections in &lt;code&gt;availableConnections&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;No connections available in &lt;code&gt;availableConnections&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If we have not reached the max pool &lt;code&gt;size&lt;/code&gt;, the Pool creates a new connection and puts it in the &lt;code&gt;connectingConnections&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Any credentials are applied to the new connection and if the connection process is successful, the connection is then moved to &lt;code&gt;availableConnections&lt;/code&gt; and the operation is re-scheduled for execution.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;shrinking-the-pool&#34;&gt;Shrinking the Pool&lt;/h3&gt;

&lt;p&gt;The pool shrinks when a connection is idle for longer than the specified socket timeout. When the connection closes it gets removed from the pool.&lt;/p&gt;

&lt;h2 id=&#34;operation-life-cycle&#34;&gt;Operation Life-cycle&lt;/h2&gt;

&lt;p&gt;The Life-cycle of an operation is as follows.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;User calls the &lt;code&gt;Pool.write&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;The operation is put at the end of the internal operations &lt;code&gt;queue&lt;/code&gt; array.&lt;/li&gt;
&lt;li&gt;The internal &lt;code&gt;_execute&lt;/code&gt; method is called which picks the first operation of the queue and attempts to execute it against an available connection.&lt;/li&gt;
&lt;li&gt;The operation is associated with a specific connection for the duration of the operation.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;Pool.write&lt;/code&gt; options provide for a special &lt;code&gt;monitoring&lt;/code&gt; options that will schedule the operation at the start of the &lt;code&gt;queue&lt;/code&gt; array to give it priority over any other operations currently queued up. This is used to execute the &lt;code&gt;ismaster&lt;/code&gt; commands for things like &lt;code&gt;Replicaset&lt;/code&gt; monitoring.&lt;/p&gt;

&lt;h2 id=&#34;error-handling&#34;&gt;Error handling&lt;/h2&gt;

&lt;p&gt;When a single connection fails (closes, times out) and there is an operation in flight on that connection the pool will flush out that operation as an error to the end user by calling its associated callback.&lt;/p&gt;

&lt;h2 id=&#34;pool-destruction&#34;&gt;Pool destruction&lt;/h2&gt;

&lt;p&gt;When the &lt;code&gt;Pool.destroy&lt;/code&gt; method is called the pool will go into the &lt;code&gt;destroying&lt;/code&gt; state and will drain the reminder of the operation queue before moving to the &lt;code&gt;destroy&lt;/code&gt; state.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>APM</title>
      <link>/node-mongodb-native/2.2/reference/management/apm/</link>
      <pubDate>Thu, 19 Mar 2015 12:53:26 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/management/apm/</guid>
      <description>

&lt;h1 id=&#34;apm&#34;&gt;APM&lt;/h1&gt;

&lt;p&gt;Application Performance Monitoring support is a driver
feature that allows monitoring services to hook into the
driver in a forward compatible and stable way. The API is
not applied to the driver unless explicitly initialized to
avoid any performance penalties.&lt;/p&gt;

&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;

&lt;p&gt;The following code example hooks into all the available features
of the APM API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var listener = require(&#39;mongodb&#39;).instrument({
  operationIdGenerator: {
    operationId: 1,

    next: function() {
      return this.operationId++;
    }
  },

  timestampGenerator: {
    current: function() {
      return new Date().getTime();
    },

    duration: function(start, end) {
      return end - start;
    }
  }  
}, function(err, instrumentations) {
  // Instrument the driver  
});

listener.on(&#39;started&#39;, function(event) {
  // command start event (see https://github.com/mongodb/specifications/blob/master/source/command-monitoring/command-monitoring.rst)
});

listener.on(&#39;succeeded&#39;, function(event) {
  // command success event (see https://github.com/mongodb/specifications/blob/master/source/command-monitoring/command-monitoring.rst)
});

listener.on(&#39;failed&#39;, function(event) {
  // command failure event (see https://github.com/mongodb/specifications/blob/master/source/command-monitoring/command-monitoring.rst)
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two main aspects to the APM API. The first one is the command monitoring specification and the second one is the instrumentation method.&lt;/p&gt;

&lt;h2 id=&#34;command-monitoring&#34;&gt;Command Monitoring&lt;/h2&gt;

&lt;p&gt;Command monitoring is based on the cross-driver specification for MongoDB found in the Command monitoring &lt;a href=&#34;https://github.com/mongodb/specifications/blob/master/source/command-monitoring/command-monitoring.rst&#34;&gt;specification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Command monitoring specification is a low-level monitoring specification that sends a notification when a new command is executed against MongoDB and if it fails or succeeds. In most cases this is straightforward and you will receive a single start and either a success or failure event.&lt;/p&gt;

&lt;p&gt;In this example, the user executes the &lt;code&gt;isMaster&lt;/code&gt; command against the server and receives the following messages (full objects are abbreviated for simplicity&amp;rsquo;s sake). When the &lt;code&gt;isMaster&lt;/code&gt; command starts execution we receive the following event (this result is from &lt;code&gt;JSON.stringify&lt;/code&gt;; in the real event the connectionId is the actual connection object the command was executed against).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  &amp;quot;command&amp;quot;: {
    &amp;quot;ismaster&amp;quot;: true
  },
  &amp;quot;databaseName&amp;quot;: &amp;quot;system&amp;quot;,
  &amp;quot;commandName&amp;quot;: &amp;quot;ismaster&amp;quot;,
  &amp;quot;requestId&amp;quot;: 7,
  &amp;quot;operationId&amp;quot;: 1,
  &amp;quot;connectionId&amp;quot;: {
    &amp;quot;id&amp;quot;: 8,
    &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
    &amp;quot;port&amp;quot;: 27017
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;requestId&lt;/code&gt; is the id used for the wire protocol message sent to MongoDB and allows you to correlate the commands executed on MongoDB with the commands from the driver.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;operationId&lt;/code&gt; is an id that is used to group commands into a single logical command execution. Use cases are queries and batch writes where a single logical operation might be executed as multiple commands to the server. For a query this might mean it gets executed as a &lt;code&gt;find&lt;/code&gt; command and &lt;em&gt;n&lt;/em&gt; number of &lt;code&gt;getMore&lt;/code&gt; commands as well as a &lt;code&gt;killCursors&lt;/code&gt; command. For bulk writes the logical grouping might contain &lt;code&gt;n&lt;/code&gt; individual write operations. The goal of &lt;code&gt;operationId&lt;/code&gt; is to allow APM providers to correlate the breakdown of a cursor or bulk operation with the method called by the user.&lt;/p&gt;

&lt;p&gt;A typical example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;db.collection(&#39;data&#39;).find().batchSize(2).toArray(function(err, docs) {
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That might be translated to &lt;code&gt;1&lt;/code&gt; find, &lt;code&gt;n&lt;/code&gt; getMores and &lt;code&gt;0|1&lt;/code&gt; killCursors.&lt;/p&gt;

&lt;p&gt;After the command executed successfully it sends the following result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  &amp;quot;duration&amp;quot;: 0,
  &amp;quot;commandName&amp;quot;: &amp;quot;ismaster&amp;quot;,
  &amp;quot;requestId&amp;quot;: 7,
  &amp;quot;operationId&amp;quot;: 1,
  &amp;quot;connectionId&amp;quot;: {
    &amp;quot;id&amp;quot;: 8,
    &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
    &amp;quot;port&amp;quot;: 27017
  },
  &amp;quot;reply&amp;quot;: {
    &amp;quot;ismaster&amp;quot;: true,
    &amp;quot;maxBsonObjectSize&amp;quot;: 16777216,
    &amp;quot;maxMessageSizeBytes&amp;quot;: 48000000,
    &amp;quot;maxWriteBatchSize&amp;quot;: 1000,
    &amp;quot;localTime&amp;quot;: &amp;quot;2015-08-04T10:26:01.445Z&amp;quot;,
    &amp;quot;maxWireVersion&amp;quot;: 3,
    &amp;quot;minWireVersion&amp;quot;: 0,
    &amp;quot;ok&amp;quot;: 1
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the &lt;code&gt;requestId&lt;/code&gt; and &lt;code&gt;operationId&lt;/code&gt; match up to the start message, allowing the user of the API to correlate the two events.&lt;/p&gt;

&lt;p&gt;The next example shows a complete &lt;code&gt;find&lt;/code&gt; operation that results in multiple &lt;code&gt;getMore&lt;/code&gt; responses.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  &amp;quot;command&amp;quot;: {
    &amp;quot;find&amp;quot;: &amp;quot;apm_test_2&amp;quot;,
    &amp;quot;filter&amp;quot;: {
      &amp;quot;a&amp;quot;: 1
    },
    &amp;quot;sort&amp;quot;: {
      &amp;quot;a&amp;quot;: 1
    },
    &amp;quot;projection&amp;quot;: {
      &amp;quot;_id&amp;quot;: 1,
      &amp;quot;a&amp;quot;: 1
    },
    &amp;quot;limit&amp;quot;: 100,
    &amp;quot;skip&amp;quot;: 1,
    &amp;quot;hint&amp;quot;: {
      &amp;quot;_id&amp;quot;: 1
    },
    &amp;quot;batchSize&amp;quot;: 2,
    &amp;quot;comment&amp;quot;: &amp;quot;some comment&amp;quot;,
    &amp;quot;maxScan&amp;quot;: 1000,
    &amp;quot;maxTimeMS&amp;quot;: 5000,
    &amp;quot;noCursorTimeout&amp;quot;: true
  },
  &amp;quot;databaseName&amp;quot;: &amp;quot;integration_tests&amp;quot;,
  &amp;quot;commandName&amp;quot;: &amp;quot;find&amp;quot;,
  &amp;quot;requestId&amp;quot;: 44,
  &amp;quot;operationId&amp;quot;: 39,
  &amp;quot;connectionId&amp;quot;: {
    &amp;quot;id&amp;quot;: 19,
    &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
    &amp;quot;port&amp;quot;: 27017
  }
}
{
  &amp;quot;duration&amp;quot;: 1,
  &amp;quot;commandName&amp;quot;: &amp;quot;find&amp;quot;,
  &amp;quot;requestId&amp;quot;: 44,
  &amp;quot;operationId&amp;quot;: 39,
  &amp;quot;connectionId&amp;quot;: {
    &amp;quot;id&amp;quot;: 19,
    &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
    &amp;quot;port&amp;quot;: 27017
  },
  &amp;quot;reply&amp;quot;: [
    {
      &amp;quot;_id&amp;quot;: &amp;quot;55c096386e3b2283b70c294d&amp;quot;,
      &amp;quot;a&amp;quot;: 1
    },
    {
      &amp;quot;_id&amp;quot;: &amp;quot;55c096386e3b2283b70c294e&amp;quot;,
      &amp;quot;a&amp;quot;: 1
    }
  ]
}
{
  &amp;quot;command&amp;quot;: {
    &amp;quot;getMore&amp;quot;: &amp;quot;104961726686&amp;quot;,
    &amp;quot;collection&amp;quot;: &amp;quot;apm_test_2&amp;quot;,
    &amp;quot;batchSize&amp;quot;: 2,
    &amp;quot;maxTimeMS&amp;quot;: 5000
  },
  &amp;quot;databaseName&amp;quot;: &amp;quot;integration_tests&amp;quot;,
  &amp;quot;commandName&amp;quot;: &amp;quot;getMore&amp;quot;,
  &amp;quot;requestId&amp;quot;: 44,
  &amp;quot;operationId&amp;quot;: 39,
  &amp;quot;connectionId&amp;quot;: {
    &amp;quot;id&amp;quot;: 19,
    &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
    &amp;quot;port&amp;quot;: 27017
  }
}
{
  &amp;quot;duration&amp;quot;: 1,
  &amp;quot;commandName&amp;quot;: &amp;quot;getMore&amp;quot;,
  &amp;quot;requestId&amp;quot;: 44,
  &amp;quot;operationId&amp;quot;: 39,
  &amp;quot;connectionId&amp;quot;: {
    &amp;quot;id&amp;quot;: 19,
    &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
    &amp;quot;port&amp;quot;: 27017
  },
  &amp;quot;reply&amp;quot;: [
    {
      &amp;quot;_id&amp;quot;: &amp;quot;55c096386e3b2283b70c294f&amp;quot;,
      &amp;quot;a&amp;quot;: 1
    },
    {
      &amp;quot;_id&amp;quot;: &amp;quot;55c096386e3b2283b70c2950&amp;quot;,
      &amp;quot;a&amp;quot;: 1
    }
  ]
}
{
  &amp;quot;command&amp;quot;: {
    &amp;quot;getMore&amp;quot;: &amp;quot;104961726686&amp;quot;,
    &amp;quot;collection&amp;quot;: &amp;quot;apm_test_2&amp;quot;,
    &amp;quot;batchSize&amp;quot;: 2,
    &amp;quot;maxTimeMS&amp;quot;: 5000
  },
  &amp;quot;databaseName&amp;quot;: &amp;quot;integration_tests&amp;quot;,
  &amp;quot;commandName&amp;quot;: &amp;quot;getMore&amp;quot;,
  &amp;quot;requestId&amp;quot;: 45,
  &amp;quot;operationId&amp;quot;: 39,
  &amp;quot;connectionId&amp;quot;: {
    &amp;quot;id&amp;quot;: 19,
    &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
    &amp;quot;port&amp;quot;: 27017
  }
}
{
  &amp;quot;duration&amp;quot;: 0,
  &amp;quot;commandName&amp;quot;: &amp;quot;getMore&amp;quot;,
  &amp;quot;requestId&amp;quot;: 45,
  &amp;quot;operationId&amp;quot;: 39,
  &amp;quot;connectionId&amp;quot;: {
    &amp;quot;id&amp;quot;: 19,
    &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
    &amp;quot;port&amp;quot;: 27017
  },
  &amp;quot;reply&amp;quot;: [
    {
      &amp;quot;_id&amp;quot;: &amp;quot;55c096386e3b2283b70c2951&amp;quot;,
      &amp;quot;a&amp;quot;: 1
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; all the documents share the same &lt;code&gt;operationId&lt;/code&gt;, allowing the
APM API user to correctly map the low level commands to the logical
command executed by the user (in this case &lt;code&gt;toArray&lt;/code&gt; on a cursor).&lt;/p&gt;

&lt;h3 id=&#34;operationidgenerator&#34;&gt;operationIdGenerator&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;operationIdGenerator&lt;/code&gt; option allows the API user to pass in a
custom &lt;code&gt;operationId&lt;/code&gt; generator object. You can use this object to
synchronize internal request IDs in the APM client with the low-level
command monitoring API. This synchronization makes it possible to
associate the logical method called by the user&amp;rsquo;s code with the
low-level commands issued to MongoDB. This allows for a richer
APM experience and performance breakdown. Below is a simple
&lt;code&gt;operationIdGenerator&lt;/code&gt; example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var generator = {
  operationId: 1,

  next: function() {
    return this.operationId++;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;timestampgenerator&#34;&gt;timestampGenerator&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;timestampGenerator&lt;/code&gt; option lets the API user to override the method
used to timestamp the command monitoring events with a custom timestamp
type. The generator contains two methods. &lt;code&gt;current&lt;/code&gt; returns the current
timestamp&lt;code&gt;and&lt;/code&gt;duration&lt;code&gt;calculates the total operation duration
between the&lt;/code&gt;start&lt;code&gt;and&lt;/code&gt;end` time. Below is a simple generator example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var generator = {
  current: function() {
    return new Date().getTime();
  },

  duration: function(start, end) {
    return end - start;
  }
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;instrumentation&#34;&gt;Instrumentation&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;instrumentation&lt;/code&gt; callback returns the instrumentation points in
the driver and associated metadata. In the following example, the
result shown is the result from performing &lt;code&gt;JSON.stringify&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;Gridstore&amp;quot;,
  &amp;quot;stream&amp;quot;: true,
  &amp;quot;instrumentations&amp;quot;: [
    {
      &amp;quot;methods&amp;quot;: [
        &amp;quot;open&amp;quot;,
        &amp;quot;getc&amp;quot;,
        &amp;quot;puts&amp;quot;,
        &amp;quot;write&amp;quot;,
        &amp;quot;writeFile&amp;quot;,
        &amp;quot;close&amp;quot;,
        &amp;quot;unlink&amp;quot;,
        &amp;quot;readlines&amp;quot;,
        &amp;quot;rewind&amp;quot;,
        &amp;quot;read&amp;quot;,
        &amp;quot;tell&amp;quot;,
        &amp;quot;seek&amp;quot;
      ],
      &amp;quot;options&amp;quot;: {
        &amp;quot;callback&amp;quot;: true,
        &amp;quot;promise&amp;quot;: true
      }
    },
    {
      &amp;quot;methods&amp;quot;: [
        &amp;quot;eof&amp;quot;
      ],
      &amp;quot;options&amp;quot;: {
        &amp;quot;callback&amp;quot;: false,
        &amp;quot;promise&amp;quot;: false,
        &amp;quot;returns&amp;quot;: [
          null
        ]
      }
    },
    {
      &amp;quot;methods&amp;quot;: [
        &amp;quot;stream&amp;quot;
      ],
      &amp;quot;options&amp;quot;: {
        &amp;quot;callback&amp;quot;: false,
        &amp;quot;promise&amp;quot;: false,
        &amp;quot;returns&amp;quot;: [
          null
        ]
      }
    },
    {
      &amp;quot;methods&amp;quot;: [
        &amp;quot;destroy&amp;quot;
      ],
      &amp;quot;options&amp;quot;: {
        &amp;quot;callback&amp;quot;: false,
        &amp;quot;promise&amp;quot;: false
      }
    },
    {
      &amp;quot;methods&amp;quot;: [
        &amp;quot;chunkCollection&amp;quot;,
        &amp;quot;collection&amp;quot;
      ],
      &amp;quot;options&amp;quot;: {
        &amp;quot;callback&amp;quot;: true,
        &amp;quot;promise&amp;quot;: false,
        &amp;quot;returns&amp;quot;: [
          null
        ]
      }
    },
    {
      &amp;quot;methods&amp;quot;: [
        &amp;quot;exist&amp;quot;,
        &amp;quot;list&amp;quot;,
        &amp;quot;read&amp;quot;,
        &amp;quot;readlines&amp;quot;,
        &amp;quot;unlink&amp;quot;
      ],
      &amp;quot;options&amp;quot;: {
        &amp;quot;callback&amp;quot;: true,
        &amp;quot;promise&amp;quot;: true,
        &amp;quot;static&amp;quot;: true
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; the name of the class exposed for instrumentation.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stream&lt;/code&gt; tells the user if the object can operate as a Node.js stream.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instrumentations&lt;/code&gt; an array which contains all the methods available
for instrumentation. The methods are grouped
by method characteristics. All methods that support a callback as well
as a promise will be grouped in a single instrumentation. This
simplifies the code to perform the actual instrumentation.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  &amp;quot;methods&amp;quot;: [
    &amp;quot;open&amp;quot;,
    &amp;quot;getc&amp;quot;,
    &amp;quot;puts&amp;quot;,
    &amp;quot;write&amp;quot;,
    &amp;quot;writeFile&amp;quot;,
    &amp;quot;close&amp;quot;,
    &amp;quot;unlink&amp;quot;,
    &amp;quot;readlines&amp;quot;,
    &amp;quot;rewind&amp;quot;,
    &amp;quot;read&amp;quot;,
    &amp;quot;tell&amp;quot;,
    &amp;quot;seek&amp;quot;
  ],
  &amp;quot;options&amp;quot;: {
    &amp;quot;callback&amp;quot;: true,
    &amp;quot;promise&amp;quot;: true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;methods&lt;/code&gt; array contains all the methods that have the options
&lt;code&gt;callback=true&lt;/code&gt; and &lt;code&gt;promise=true&lt;/code&gt; for the GridStore prototype.
The available options are:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Options&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;callback&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The method supports a callback&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;promise&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The method can return a promise&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;static&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The method is a static method (not on the prototype)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;returns&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The method can return one of the types in the array&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Below is a very basic instrumentation example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var listener = require(&#39;../..&#39;).instrument(function(err, instrumentations) {
  instrumentations.forEach(function(obj) {
    var object = obj.obj;

    // Iterate over all the methods that are just callback with no return
    obj.instrumentations.forEach(function(instr) {
      var options = instr.options;

      if(options.callback
        &amp;amp;&amp;amp; !options.returns &amp;amp;&amp;amp; !options.static) {

        // Method name
        instr.methods.forEach(function(method) {
          var applyMethod = function(_method) {
            var func = object.prototype[_method];

            overrides.push({
              obj: object.prototype, method: _method, func: func
            });

            object.prototype[_method] = function() {
              if(!methodsCalled[_method]) methodsCalled[_method] = 0;
              methodsCalled[_method] = methodsCalled[_method] + 1;
              var args = Array.prototype.slice.call(arguments, 0);
              func.apply(this, args);                
            }                
          }

          applyMethod(method);
        });
      }
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This instrumentation only overrides methods that have callbacks and
ignores promises, so it&amp;rsquo;s not a complete solution, but shows how an
API user can structure code to tap into the exposed surface of the
driver.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Topology Monitoring</title>
      <link>/node-mongodb-native/2.2/reference/management/sdam-monitoring/</link>
      <pubDate>Thu, 19 Mar 2015 12:53:26 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/management/sdam-monitoring/</guid>
      <description>

&lt;h1 id=&#34;topology-management&#34;&gt;Topology Management&lt;/h1&gt;

&lt;p&gt;The Node.js driver &lt;code&gt;2.1.10&lt;/code&gt; or higher features SDAM Monitoring events,
allowing an application or tool to monitor changes in the drivers
view of a single server, replica set or &lt;code&gt;mongos&lt;/code&gt;. This allows an
application to react to changes of topology, such as a secondary
joining or leaving a replica set.&lt;/p&gt;

&lt;h2 id=&#34;overview-of-sdam-events&#34;&gt;Overview of SDAM events&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Event&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Applies To&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;serverOpening&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Emitted when server connection is established.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;serverClosed&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Emitted when server connection gets closed.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;serverDescriptionChanged&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Emitted when server state changes (such as from secondary to primary).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;topologyOpening&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Emitted before any server connections are performed.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;topologyClosed&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Server, Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Emitted when topology connections have all closed.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;topologyDescriptionChanged&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Emitted when the topology shape changes, such as a new primary being elected or a mongos proxy disconnecting.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;serverHeartbeatStarted&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Emitted before the ismaster command is issued to a MongoDB server.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;serverHeartbeatSucceeded&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Emitted after a successful ismaster command was issued to a MongoDB server.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;serverHeartbeatFailed&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Replicaset, Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Emitted if a ismaster command failed against a specific MongoDB server.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;simple-code-example&#34;&gt;Simple Code Example&lt;/h2&gt;

&lt;p&gt;The following example demonstrates how to connect to a replica set and monitor all the events that are emitted by the replica set topology.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient;

var url = &#39;mongodb://localhost:31000,localhost:31001/db?replicaSet=rs&#39;;

MongoClient.connect(url, function(err, db) {
  if(err) throw err;

  db.topology.on(&#39;serverDescriptionChanged&#39;, function(event) {
    console.log(&#39;received serverDescriptionChanged&#39;);
    console.log(JSON.stringify(event, null, 2));
  });

  db.topology.on(&#39;serverHeartbeatStarted&#39;, function(event) {
    console.log(&#39;received serverHeartbeatStarted&#39;);
    console.log(JSON.stringify(event, null, 2));
  });

  db.topology.on(&#39;serverHeartbeatSucceeded&#39;, function(event) {
    console.log(&#39;received serverHeartbeatSucceeded&#39;);
    console.log(JSON.stringify(event, null, 2));
  });

  db.topology.on(&#39;serverHeartbeatFailed&#39;, function(event) {
    console.log(&#39;received serverHeartbeatFailed&#39;);
    console.log(JSON.stringify(event, null, 2));
  });

  db.topology.on(&#39;serverOpening&#39;, function(event) {
    console.log(&#39;received serverOpening&#39;);
    console.log(JSON.stringify(event, null, 2));
  });

  db.topology.on(&#39;serverClosed&#39;, function(event) {
    console.log(&#39;received serverClosed&#39;);
    console.log(JSON.stringify(event, null, 2));
  });

  db.topology.on(&#39;topologyOpening&#39;, function(event) {
    console.log(&#39;received topologyOpening&#39;);
    console.log(JSON.stringify(event, null, 2));
  });

  db.topology.on(&#39;topologyClosed&#39;, function(event) {
    console.log(&#39;received topologyClosed&#39;);
    console.log(JSON.stringify(event, null, 2));
  });

  db.topology.on(&#39;topologyDescriptionChanged&#39;, function(event) {
    console.log(&#39;received topologyDescriptionChanged&#39;);
    console.log(JSON.stringify(event, null, 2));
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;example-documents-returned-for-each-event-type&#34;&gt;Example Documents Returned For Each Event Type&lt;/h2&gt;

&lt;p&gt;The following examples serve as a guide to the format of the returned documents.&lt;/p&gt;

&lt;h3 id=&#34;serverdescriptionchanged&#34;&gt;serverDescriptionChanged&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{ address: &#39;localhost:27017&#39;,
  arbiters: [],
  hosts: [],
  passives: [],
  type: &#39;RSPrimary&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The type can be one of the following values.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RSPrimary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Primary server&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RSSecondary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Secondary server&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RSArbiter&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Arbiter&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Standalone&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Standalone server&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Unknown&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Unknown server&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Mongos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Mongos proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;serverheartbeatstarted&#34;&gt;serverHeartbeatStarted&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{ connectionId: &#39;localhost:27017&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;serverheartbeatsucceeded&#34;&gt;serverHeartbeatSucceeded&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{ durationMS: 20,
  reply: {
    setName: &amp;quot;rs&amp;quot;, setVersion: 1, electionId: new ObjectId(),
    maxBsonObjectSize : 16777216, maxMessageSizeBytes : 48000000,
    maxWriteBatchSize : 1000, localTime : new Date(),
    maxWireVersion : 4, minWireVersion : 0, ok : 1,
    hosts: [&amp;quot;localhost:32000&amp;quot;, &amp;quot;localhost:32001&amp;quot;],
    arbiters: [&amp;quot;localhost:32002&amp;quot;]
  },
  connectionId: &#39;localhost:27017&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;serverheartbeatfailed&#34;&gt;serverHeartbeatFailed&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{ durationMS: 20,
  err: new MongoError(&#39;some error&#39;),
  connectionId: &#39;localhost:27017&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;serveropening&#34;&gt;serverOpening&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{ topologyId: 0, name: &#39;localhost:27017&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;serverclosed&#34;&gt;serverClosed&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{ topologyId: 0, name: &#39;localhost:27017&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;topologyopening&#34;&gt;topologyOpening&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{ topologyId: 0 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;topologyclosed&#34;&gt;topologyClosed&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{ topologyId: 0 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;topologydescriptionchanged&#34;&gt;topologyDescriptionChanged&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  topologyId: 0,
  previousDescription: {
    topologyType: &amp;quot;ReplicaSetNoPrimary&amp;quot;,
    setName: &amp;quot;rs&amp;quot;,
    servers: [
      {
        type: &amp;quot;RSSecondary&amp;quot;,
        address: &amp;quot;localhost:32001&amp;quot;,
        hosts: [
          &amp;quot;localhost:32000&amp;quot;,
          &amp;quot;localhost:32001&amp;quot;
        ],
        arbiters: [
          &amp;quot;localhost:32002&amp;quot;
        ],
        setName: &amp;quot;rs&amp;quot;
      },
      {
        type: &amp;quot;RSSecondary&amp;quot;,
        address: &amp;quot;localhost:32000&amp;quot;,
        hosts: [
          &amp;quot;localhost:32000&amp;quot;,
          &amp;quot;localhost:32001&amp;quot;
        ],
        arbiters: [
          &amp;quot;localhost:32002&amp;quot;
        ],
        setName: &amp;quot;rs&amp;quot;
      },
      {
        type: &amp;quot;RSArbiter&amp;quot;,
        address: &amp;quot;localhost:32002&amp;quot;,
        hosts: [
          &amp;quot;localhost:32000&amp;quot;,
          &amp;quot;localhost:32001&amp;quot;
        ],
        arbiters: [
          &amp;quot;localhost:32002&amp;quot;
        ],
        setName: &amp;quot;rs&amp;quot;
      }
    ]
  },
  newDescription: {
    topologyType: &amp;quot;ReplicaSetWithPrimary&amp;quot;,
    setName: &amp;quot;rs&amp;quot;,
    servers: [
      {
        type: &amp;quot;RSPrimary&amp;quot;,
        address: &amp;quot;localhost:32001&amp;quot;,
        hosts: [
          &amp;quot;localhost:32000&amp;quot;,
          &amp;quot;localhost:32001&amp;quot;
        ],
        arbiters: [
          &amp;quot;localhost:32002&amp;quot;
        ],
        setName: &amp;quot;rs&amp;quot;
      },
      {
        type: &amp;quot;RSSecondary&amp;quot;,
        address: &amp;quot;localhost:32000&amp;quot;,
        hosts: [
          &amp;quot;localhost:32000&amp;quot;,
          &amp;quot;localhost:32001&amp;quot;
        ],
        arbiters: [
          &amp;quot;localhost:32002&amp;quot;
        ],
        setName: &amp;quot;rs&amp;quot;
      },
      {
        type: &amp;quot;RSArbiter&amp;quot;,
        address: &amp;quot;localhost:32002&amp;quot;,
        hosts: [
          &amp;quot;localhost:32000&amp;quot;,
          &amp;quot;localhost:32001&amp;quot;
        ],
        arbiters: [
          &amp;quot;localhost:32002&amp;quot;
        ],
        setName: &amp;quot;rs&amp;quot;
      }
    ]
  },
  diff: {
    servers: [{
        &amp;quot;address&amp;quot;: &amp;quot;localhost:32000&amp;quot;,
        &amp;quot;from&amp;quot;: &amp;quot;RSSecondary&amp;quot;,
        &amp;quot;to&amp;quot;: &amp;quot;RSPrimary&amp;quot;
      }
    ]
  }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;type&lt;/code&gt; field in the server array documents can be one of the following values:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RSPrimary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Primary server&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RSSecondary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Secondary server&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RSArbiter&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Arbiter&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Standalone&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Standalone server&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Unknown&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Unknown server&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The &lt;code&gt;topologyType&lt;/code&gt; field can be one of the following values:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ReplicaSetWithPrimary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Replica set with a primary&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ReplicaSetNoPrimary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Replica set with no primary&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Unknown&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Unknown topology&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Logging</title>
      <link>/node-mongodb-native/2.2/reference/management/logging/</link>
      <pubDate>Wed, 18 Mar 2015 21:14:20 -0400</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/management/logging/</guid>
      <description>

&lt;h1 id=&#34;logging&#34;&gt;Logging&lt;/h1&gt;

&lt;p&gt;You can change the log level, filter on classes to allow only specific classes
to log, and provide your own logger implementation.&lt;/p&gt;

&lt;h2 id=&#34;setting-log-level&#34;&gt;Setting Log level&lt;/h2&gt;

&lt;p&gt;The driver allows logging at three different levels: &lt;code&gt;debug&lt;/code&gt;,
&lt;code&gt;info&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;. The default level is &lt;code&gt;error&lt;/code&gt;.
The following example demonstrates how to set the logger to &lt;code&gt;debug&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient
  , Logger = require(&#39;mongodb&#39;).Logger
  , assert = require(&#39;assert&#39;);

// Connection URL
var url = &#39;mongodb://localhost:27017/myproject&#39;;
// Use connect method to connect to the Server
MongoClient.connect(url, function(err, db) {
  assert.equal(null, err);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Set debug level
  Logger.setLevel(&#39;debug&#39;);

  // Execute command {ismaster:true} against db
  db.command({ismaster:true}, function(err, d) {
    assert.equal(null, err);
    db.close();
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;filtering-on-specific-classes&#34;&gt;Filtering On specific classes&lt;/h2&gt;

&lt;p&gt;You can set the Logger to only log specific class names. The following example
demonstrates how to log only the &lt;code&gt;Db&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient
  , Logger = require(&#39;mongodb&#39;).Logger
  , assert = require(&#39;assert&#39;);

// Connection URL
var url = &#39;mongodb://localhost:27017/myproject&#39;;
// Use connect method to connect to the Server
MongoClient.connect(url, function(err, db) {
  assert.equal(null, err);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Set debug level
  Logger.setLevel(&#39;debug&#39;);
  // Only log statements on &#39;Db&#39; class
  Logger.filter(&#39;class&#39;, [&#39;Db&#39;]);

  // Execute command {ismaster:true} against db
  db.command({ismaster:true}, function(err, d) {
    assert.equal(null, err);
    db.close();
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Driver classes available for filtering:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Db&lt;/code&gt;: The Db instance log statements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Server&lt;/code&gt;: A server instance (either standalone, a mongos or replica set member)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReplSet&lt;/code&gt;: Replica set related log statements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mongos&lt;/code&gt;: Mongos related log statements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cursor&lt;/code&gt;: Cursor log statements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pool&lt;/code&gt;: Connection Pool specific log statements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection&lt;/code&gt;: Singular connection specific log statements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ping&lt;/code&gt;: Replica set ping inquiry log statements&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can add your own classes to the logger by creating your own logger instances.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var Logger = require(&#39;mongodb&#39;).Logger
  , assert = require(&#39;assert&#39;);

var A = function() {
  var logger = Logger(&#39;A&#39;, options);

  this.do = function() {
    if(logger.isInfo()) logger.info(&#39;logging A&#39;, {});
  }
}

// Execute A
var a = new A();
a.do();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;custom-logger&#34;&gt;Custom logger&lt;/h2&gt;

&lt;p&gt;The following example demonstrates how to define a custom logger.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var MongoClient = require(&#39;mongodb&#39;).MongoClient
  , Logger = require(&#39;mongodb&#39;).Logger
  , assert = require(&#39;assert&#39;);

// Connection URL
var url = &#39;mongodb://localhost:27017/myproject&#39;;
// Use connect method to connect to the Server
MongoClient.connect(url, function(err, db) {
  assert.equal(null, err);
  console.log(&amp;quot;Connected correctly to server&amp;quot;);

  // Set debug level
  Logger.setLevel(&#39;debug&#39;);
  
  // Set our own logger
  Logger.setCurrentLogger(function(msg, context) {
    console.log(msg, context);
  });

  // Execute command {ismaster:true} against db
  db.command({ismaster:true}, function(err, d) {
    assert.equal(null, err);
    db.close();
  });
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reference</title>
      <link>/node-mongodb-native/2.2/reference/main/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/node-mongodb-native/2.2/reference/main/</guid>
      <description>

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;p&gt;The reference documentation for the Node.js driver driver focuses on high-level documentation and use-cases.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/node-mongodb-native/2.2/node-mongodb-native/2.2/reference/connecting/&#34;&gt;Connect to MongoDB&lt;/a&gt;: Documentation of the driver&amp;rsquo;s support for connecting to MongoDB servers&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/node-mongodb-native/2.2/node-mongodb-native/2.2/reference/ecmascript6/&#34;&gt;ECMAScript 6&lt;/a&gt;: Using the driver with Javascript 6.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/node-mongodb-native/2.2/node-mongodb-native/2.2/reference/management/&#34;&gt;Management&lt;/a&gt;: Documentation of the driver&amp;rsquo;s support for logging and monitoring of its
internal state&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>